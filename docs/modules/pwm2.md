# PWM Module
| Since  | Origin / Contributor  | Maintainer  | Source  |
| :----- | :-------------------- | :---------- | :------ |
| 2019-02-12 | [fikin](https://github.com/fikin) | [fikin](https://github.com/fikin) | [pwm2.c](../../../app/modules/pwm2.c)|

Module to generate PWM impulses to any of the GPIO pins. 

PWM is being generated by software using soft-interrupt TIMER1 FRC1. This module is using the timer in exclusive mode. See [understanding timer use](#understanding-timer-use) for more.

Supported frequencies are roughly from 200kHZ up to pulse/53sec with varying pulse period. For CPU160MHz values are almost double Hz / halved sec. See [understanding frequencies](#understand-frequencies) for more.

Supported are also frequency fractions even for integer-only firmware builds.

Supported are all of the GPIO pins except pin 0. 

One can generate different PWM signals to any of them at the same time. See [working with multiple frequencies](#working-with-multiple-frequencies) for more.

This module supportes CPU80MHz as well as CPU160MHz.
Using CPU160MHz is almost doubling the processing speed but not exactly. Reason being that not all parts of the code scale lineary with the CPU clock.

Typical usage is as following:
```lua
pwm2.setup_pin_hz(4,1,2,1) -- pin 4, PWM freq of 1Hz, pulse period of 2 steps, initial duty 1 period step 
pwm2.start() -- starts pwm, internal led will blink with 0.5sec interval
...
pwm2.set_duty(4, 2) -- led full off (pin is high)
...
pwm2.set_duty(4, 0) -- led full on (pin is low)
...
pwm2.stop() -- PWM stopped, gpio pin released, timer1 released
```

## Understand frequencies

All frequencines and periods internally are expressed as CPU ticks using following formula: `cpuTicksPerSecond / (frequencyHz * period)`. For example, 1kHz with 1000 period for CPU80MHz results in 80 CPU ticks per period i.e. period is 1uS long.

In order to allow for better tunning, I've added an optional frequencyDivisor argument when setting up pins. With it one can express the frequency as division between two values : `frequency / divisor`. For example to model 100,1Hz frequency one has to specify frequency of 1001 and divisor 10.

## Frequency precision

ESP's TIMER1 FRC1 is operating at fixed, own frequency of 5MHz. Therefore the precision of individual interrupt is 200ns. But OS interrupt handler itself has internal overhead, which for auto-loaded interrupts is about 80CPUTicks. With PWM2 own interrupt handler overhead of 162CPUTicks + 12CPUTicks per used pin, one can expect effective interrupt frequency from 242kHz for 1pin to 175kHz for 12 pins using CPU80MHz. Using CPU160MHz these figures almost double but not exactly.

Because TIMER1 frequency is 1/16 of CPU frequency, frequency precision is lost when converting from CPU to TIMER ticks. One can inspect exact values via [pwm.get_timer_data()](#get_timer_data). Value of `interruptTimerCPUTicks` represents desired interrupt period in CPUTicks. And `interruptTimerTicks` represents actually used interrupt period as TIMER1 ticks (1/16 of CPU).

## Working with multiple frequencies

When working with multiple pins, this module auto-discovers what would be the right underlying interrupt frequency. It does so by computing the greatest common frequency divisor and use it as common frequency for all pins.

When using same frequency for many pins, tunning frequency of single pin is enough to ensure precision.

When using different frequencies, one has to pay close attention at their greates common divisor when expressed as CPU ticks. For example, mixing 100kHz with period 2 and 0.5Hz with period 2 results in underlying interrupt period of 800CPU ticks. But changing to 100kHz+1 will easily result to divisor of 1. This is clearly non-working combination. For the moment best would be to [pwm.get_timer_data()](#get_timer_data) and observe how `interruptTimerCPUTicks` and `interruptTimerTicks` change with given input.

## Understanding timer use

This module is using soft-interrupt TIMER1 FRC1 to generate PWM signal. Since its interrupts can be masked, as some part of OS are doing it, it is possible to impact quality of generated PWM impulse. As a general principle, one should not expect high precision signal with this module.
Also note that interrupt masking is dependent on other activities happening within the ESP besides pwm2 module.

Additionally this timer is used by other modules like pwm, pcm, ws2812 and etc. This requires exclusive lock on the timer in order to ensure support for high end frequencies. Because of that simultaneous use of other modules would not be possible.

## Troubleshooting watchdog timeouts

Watchdog interrupt typically will occur if choosen frequency (and period) is too big. For CPU80MHz I guess threshold is around 120kHz with period of 2 and single pin, given not much other load on the system.

Another reason for watchdog interrupt to occur is due to mixing otherwise not very compatible frequencies when multiple pins are used. Desired frequencies when are converted to CPU ticks and then their greatest common divisor is found, are converted to TIMER1 ticks. Any of these steps imposes risk of incomatibility. For example frequency of 120kHz with period 2 results in period of 333CPU ticks, which if combined with even-resulting frequency like 1Hz with period of 2, will lead to common divisor of 1, which is clearly a non-working setup.

Both cases best are anlyzed using [pwm.get_timer_data()](#get_timer_data) wathcing values of `interruptTimerCPUTicks` and `interruptTimerTicks`. For `interruptTimerCPUTicks` and CPU80MHz anything below 400 for 12 pins or 250 for 1 pin would be cause for special attention. For CPU160MHz these values can drop almost double.

## pwm2.setup_pin_hz()
Assigns PWM frequency expressed as Hz to given pin.
This method is suitable for setting up frequencies in the range of >=1Hz.

#### Syntax
`pwm2.setup_pin_hz(pin,frequencyAsHz,pulsePeriod,initialDuty [,frequencyDivisor])`

#### Parameters
`pin` 1-12
`frequencyAsHz` desired frequency in Hz, for example 1000 for 1KHz
`pulsePeriod` discreet steps in single PWM pulse, for example 100
`initialDuty` initial duty in pulse period steps i.e. 50 for 50% pulse of 100 resolution
`frequencyDivisor` an integer to divide product of frequency and pulsePeriod. Used to form frequency fractions. By default not required.

#### Returns
`nil`

#### See also
[pwm.setup_pin_sec()](#setup_pin_sec)
[pwm.start()](#start)
[pwm.release_pin()](#release_pin)
[understanding frequencies](#understand-frequencies)
[working with multiple frequencies](#working-with-multiple-frequencies)
[pwm.get_timer_data()](#get_timer_data)

## pwm2.setup_pin_sec()
Assigns PWM frequency expressed as one impulse per second(s) to given pin.
This method is suitable for setting up frequencies in the range of 0<1Hz but expressed as seconds instead.

#### Syntax
`pwm2.setup_pin_sec(pin,frequencyAsSec,pulsePeriod,initialDuty [,frequencyDivisor])`

#### Parameters
`pin` 1-12
`frequencyAsSec` desired frequency as one impulse for given seconds, for example 2 means PWM with impulse long 2 seconds.
`pulsePeriod` discreet steps in single PWM pulse, for example 100
`initialDuty` initial duty in pulse period steps i.e. 50 for 50% pulse of 100 resolution
`frequencyDivisor` an integer to divide product of frequency and pulsePeriod. Used to form frequency fractions. By default not required.

#### Returns
`nil`

#### See also
[pwm.setup_pin_hz()](#setup_pin_hz)
[pwm.start()](#start)
[pwm.release_pin()](#release_pin)
[understanding frequencies](#understand-frequencies)
[working with multiple frequencies](#working-with-multiple-frequencies)
[pwm.get_timer_data()](#get_timer_data)

## pwm.start()
Starts PWM for all setup pins.
At this moment GPIO pins are marked as output and TIMER1 is being reserved for this module.
If the TIMER1 is already reserved by another module this method reports error.

#### Syntax
`pwm.start()`

#### Parameters
`nil`

#### Returns
`nil`

#### See also
[pwm.setup_pin_hz()](#setup_pin_hz)
[pwm.setup_pin_sec()](#setup_pin_sec)
[pwm.set_duty()](#set_duty)
[pwm.stop()](#stop)

## pwm.stop()
Stops PWM for all pins. All GPIO pins and TIMER1 are being released.
One can resume PWM with previous pin settings by calling [pwm.start()](#start) right after stop.

#### Syntax
`pwm.stop()`

#### Parameters
`nil`

#### Returns
`nil`

#### See also
[pwm.start()](#start)
[pwm.release_pin()](#release_pin)

## pwm.set_duty()
Sets duty cycle for one or more a pins. This method takes immediate effect to ongoing PWM generation.

#### Syntax
`pwm.set_duty(pin, duty [,pin,duty]*)`

#### Parameters
- `pin` 1~12, IO index
- `duty` 0~period, pwm duty cycle 

#### Returns
`nil`

#### See also
[pwm.stop()](#stop)

## pwm.release_pin()
Releases given pin from previously done setup. This method is applicable when PWM is stopped and given pin is not needed anymore.

#### Syntax
`pwm.release_pin(pin)`

#### Parameters
`pin` 1~12, IO index

#### Returns
`nil`

#### See also
[pwm.setup_pin_hz()](#setup_pin_hz)
[pwm.setup_pin_sec()](#setup_pin_sec)
[pwm.stop()](#stop)

## pwm.get_timer_data()
Prints internal data structures related to the timer. This method is usefull for people troubleshooting frequency side effects.

#### Syntax
`pwm.get_timer_data()`

#### Parameters
`nil`

#### Returns
`isStarted` bool, if true PWM2 has been started
`interruptTimerCPUTicks` int, desired timer interrupt period in CPU ticks
`interruptTimerTicks` int, actual timer interrupt period in timer ticks

#### Example
```
isStarted, interruptTimerCPUTicks, interruptTimerTicks = pwm2.get_timer_data()
```

#### See also
[pwm.setup_pin_hz()](#setup_pin_hz)
[pwm.setup_pin_sec()](#setup_pin_sec)
[pwm.get_pin_data()](#get_pin_data)

## pwm.get_pin_data()
Prints internal data structures related to given GPIO pin. This method is usefull for people troubleshooting frequency side effects.

#### Syntax
`pwm.get_pin_data(pin)`

#### Parameters
`pin` 1~12, IO index

#### Returns
`duty` int, assigned duty
`pulseResolutions` int, assigned pulse periods
`divisableFrequency` int, assigned frequency
`frequencyDivisor` int, assigned frequency divisor
`resolutionCPUTicks` int, calculated one pulse period in CPU ticks
`resolutionInterruptCounterMultiplier` int, how many timer interrupts constitute one pulse period

#### Example
```
duty, pulseResolutions, divisableFrequency, frequencyDivisor, resolutionCPUTicks, resolutionInterruptCounterMultiplier = pwm2.get_pin_data(4)
```

#### See also
[pwm.setup_pin_hz()](#setup_pin_hz)
[pwm.setup_pin_sec()](#setup_pin_sec)
[pwm.get_timer_data()](#get_timer_data)
